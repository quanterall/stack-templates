{-# START_FILE stack.yaml #-}
resolver: lts-18.14

packages:
- .

allow-different-user: true

nix:
  enable: true
  packages: []

{-# START_FILE .devcontainer/docker-compose.yaml #-}
version: '3'

services:
  {{name}}:
    image: gonz/quanterall-development:lts-18.14
    volumes:
      - ..:/workspace:cached
      - ./build/stack-work:/workspace/.stack-work:cached
    command: /bin/sh -c "while sleep 1000; do :; done"

networks:
  default:
    driver: bridge

{-# START_FILE .devcontainer/devcontainer.json #-}
{
  "name": "{{name}}",
  "service": "{{name}}",
  "workspaceFolder": "/workspace",
  "dockerComposeFile": "./docker-compose.yaml",
  "extensions": [
    "sjurmillidahl.ormolu-vscode",
    "dramforever.vscode-ghc-simple",
    "lunaryorn.hlint",
    "gonzooo.at-notes",
    "sleistner.vscode-fileutils",
    "fayras.simple-new-file",
    "jcanero.hoogle-vscode"
  ],
  "settings": {
    "[haskell]": {
      "editor.tabSize": 2,
      "editor.formatOnSave": true,
      "editor.defaultFormatter": "sjurmillidahl.ormolu-vscode",
      "editor.renderIndentGuides": true
    }
  }
}

{-# START_FILE hie.yaml #-}
cradle:
  stack:
      component: {{name}}:lib

{-# START_FILE .gitignore #-}
*.hi
*.o
.hsenv*
cabal-dev/
.stack-work/
.cabal-sandbox
cabal.sandbox.config
.DS_Store
*.swp
*~
\#*
.devcontainer/build

{-# START_FILE README.md #-}
## {{name}}

Run this project with:

```bash
$ stack run
Hello, world!
```

{-# START_FILE package.yaml #-}
name:    {{name}}
version: "0.0.0"

dependencies:

- base >=4.9.1.0 && <5

default-extensions:
- ApplicativeDo
- BangPatterns
- BinaryLiterals
- ConstraintKinds
- DataKinds
- DefaultSignatures
- DeriveDataTypeable
- DeriveFoldable
- DeriveFunctor
- DeriveGeneric
- DeriveTraversable
- DeriveLift
- DerivingStrategies
- DoAndIfThenElse
- DuplicateRecordFields
- EmptyDataDecls
- EmptyCase
- ExistentialQuantification
- FlexibleContexts
- FlexibleInstances
- FunctionalDependencies
- GADTs
- GeneralizedNewtypeDeriving
- InstanceSigs
- KindSignatures
- LambdaCase
- MultiParamTypeClasses
- MultiWayIf
- NamedFieldPuns
- NoImplicitPrelude
- OverloadedStrings
- PartialTypeSignatures
- PatternGuards
- PolyKinds
- RankNTypes
- RecordWildCards
- ScopedTypeVariables
- StandaloneDeriving
- TupleSections
- TypeFamilies
- TypeSynonymInstances
- ViewPatterns
- TypeApplications

ghc-options:
- -Wall
- -Wcompat
- -Widentities
- -Wincomplete-record-updates
- -Wincomplete-uni-patterns
- -Wpartial-fields
- -Wredundant-constraints
- -Wwarn=deprecations
- -Werror=incomplete-patterns

# The library contains all of our application code. The executable
# defined below is just a thin wrapper.
library:
  source-dirs: src

# Runnable executable for our application
executables:
  {{name}}:
    main: Main.hs
    source-dirs: app
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}

# Test suite
tests:
  {{name}}-test:
    main: Spec.hs
    source-dirs: test
    ghc-options: -Wall
    dependencies:
    - {{name}}
    - hspec >=2.0.0

{-# START_FILE app/Main.hs #-}
module Main where

import qualified Library
import Prelude

-- This `main` function just delegates to the library's definition of `main`
main :: IO ()
main = Library.runMain

{-# START_FILE src/Library.hs #-}
module Library where

import Prelude

runMain :: IO ()
runMain = do
  putStrLn "Hello, World!"

{-# START_FILE test/Spec.hs #-}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}

{-# START_FILE default.nix #-}
let
  # Read in the Niv sources
  sources = import ./nix/sources.nix {};
  # If ./nix/sources.nix file is not found run:
  #   niv init
  #   niv add input-output-hk/haskell.nix -n haskellNix

  # Fetch the haskell.nix commit we have pinned with Niv
  haskellNix = import sources.haskellNix {};
  # If haskellNix is not found run:
  #   niv add input-output-hk/haskell.nix -n haskellNix

  # Import nixpkgs and pass the haskell.nix provided nixpkgsArgs
  pkgs = import
    # haskell.nix provides access to the nixpkgs pins which are used by our CI,
    # hence you will be more likely to get cache hits when using these.
    # But you can also just use your own, e.g. '<nixpkgs>'.
    haskellNix.sources.nixpkgs-unstable
    # These arguments passed to nixpkgs, include some patches and also
    # the haskell.nix functionality itself as an overlay.
    haskellNix.nixpkgsArgs;
in pkgs.haskell-nix.project {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = "{{name}}";
    src = ./.;
  };
}

{-# START_FILE shell.nix #-}
let
  pkgs = import <nixpkgs> { };
in (import ./default.nix).shellFor {
  withHoogle = true;

  tools = {
    cabal = "3.2.0.0";
    hlint = "latest";
    ormolu = "0.3.1.0";
  };

  exactDeps = true;
}

{-# START_FILE .ghci #-}
:set -package pretty-simple
:set -XOverloadedStrings
:set -interactive-print=Text.Pretty.Simple.pPrint
import qualified Prelude
:def hoogle \x -> Prelude.pure Prelude.$ ":!hoogle " Prelude.<> x
:set prompt "Q> "

{-# START_FILE .vscode/extensions.json #-}
{
	// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.
	// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp

	// List of extensions which should be recommended for users of this workspace.
	"recommendations": [
		"sjurmillidahl.ormolu-vscode",
    "dramforever.vscode-ghc-simple",
    "lunaryorn.hlint",
    "gonzooo.at-notes",
    "sleistner.vscode-fileutils",
    "fayras.simple-new-file",
    "jcanero.hoogle-vscode"
	],
	// List of extensions recommended by VS Code that should not be recommended for users of this workspace.
	"unwantedRecommendations": []
}