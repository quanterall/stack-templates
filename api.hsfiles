{-# START_FILE app/Main.hs #-}
{-# LANGUAGE TemplateHaskell #-}

import Options.Applicative.Simple
import qualified Paths_{{name-as-varid}}
import Qtility
import Run
import Types

main :: IO ()
main = do
  (options, ()) <-
    simpleOptions
      $(simpleVersion Paths_{{name-as-varid}}.version)
      "Header for command line arguments"
      "Program description, also for command line arguments"
      ( Options
          <$> switch
            ( long "verbose"
                <> short 'v'
                <> help "Verbose output?"
            )
          <*> option
            auto
            ( long "port"
                <> short 'p'
                <> help "Port to listen on"
                <> value 3000
            )
          <*> option
            auto
            ( long "database"
                <> short 'd'
                <> help "Database to use"
                <> value "{{name}}"
            )
      )
      empty
  runMain options

{-# START_FILE src/Run.hs #-}
module Run where

import API
import Data.Pool
import Database.PostgreSQL.Simple
import Network.Wai (Application)
import Network.Wai.Handler.Warp (run)
import Qtility
import Qtility.Database (runDB, runMasterDB')
import Qtility.Database.Migration (createMigrationTable)
import Qtility.Database.Migration.Queries (applyMigrations)
import Qtility.Database.Queries (createDatabaseIfNotExists)
import Types

runMain :: Options -> IO ()
runMain options = do
  runServer options

runServer :: Options -> IO ()
runServer options = do
  logOptions <- logOptionsHandle stdout (options ^. optionsVerbose)
  withLogFunc logOptions $ \logFunc -> do
    masterPool <-
      createPool
        (connectPostgreSQL "host=localhost port=5432 user=postgres password=postgres dbname=postgres")
        close
        1
        2
        5
    pool <-
      createPool
        (connectPostgreSQL "host=localhost port=5432 user=postgres password=postgres dbname={{name}}")
        close
        1
        2
        10
    let initialState =
          App
            { _appPostgresqlPool = pool,
              _appPostgresqlMasterPool = masterPool,
              _appLogFunc = logFunc,
              _appOptions = options
            }
    runRIO pool $ do
      migrations <- createMigrationTable Nothing "migrations"
      runDB $ applyMigrations Nothing migrations
    run (options ^. optionsPort) $ application initialState

createApplication :: Options -> IO (App, Application)
createApplication options = do
  let connectionString = "host=localhost port=5432 user=postgres password=postgres dbname="
  masterPool <-
      createPool
        (connectPostgreSQL "host=localhost port=5432 user=postgres password=postgres dbname=postgres")
        close
        1
        2
        5 
  runRIO masterPool $
    runMasterDB' $ createDatabaseIfNotExists (options ^. optionsDatabase) "postgres" 
  pool <-
    createPool
      (connectPostgreSQL $ connectionString <> (options ^. optionsDatabase . unwrap))
      close
      1
      2
      10
  let app =
        App
          { _appPostgresqlPool = pool,
            _appPostgresqlMasterPool = masterPool,
            _appLogFunc = mempty,
            _appOptions = options
          }
  pure (app, application app)

{-# START_FILE src/Types.hs #-}
{-# LANGUAGE TemplateHaskell #-}

module Types where

import Data.OpenApi
import qualified Data.OpenApi as OpenApi
import Data.Pool (Pool)
import Database.PostgreSQL.Simple (Connection)
import Database.PostgreSQL.Simple.FromField (FromField (..))
import Database.PostgreSQL.Simple.FromRow (FromRow (..), field)
import Qtility
import Qtility.Database (HasPostgresqlMasterPool (..), HasPostgresqlPool (..))
import Qtility.Database.Types (DatabaseName)
import Qtility.TH.OpenApi (deriveSchema)
import RIO.Time (UTCTime)

type AppM = RIO App

data WithKey k a = WithKey
  { _withKeyId :: !k,
    _withKeyValue :: !a
  }
  deriving (Eq, Show, Generic)

data Board = Board
  { _boardName :: !Text,
    _boardColor :: !Text,
    _boardCreatedAt :: !UTCTime,
    _boardUpdatedAt :: !UTCTime
  }
  deriving (Eq, Show, Generic)

data List = List
  { _listBoardId :: !(Maybe Int64),
    _listName :: !Text,
    _listCreatedAt :: !UTCTime,
    _listUpdatedAt :: !UTCTime
  }
  deriving (Eq, Show, Generic)

data Label = Label
  { _labelName :: !Text,
    _labelColor :: !Text,
    _labelCreatedAt :: !UTCTime,
    _labelUpdatedAt :: !UTCTime
  }
  deriving (Eq, Show, Generic)

data Card = Card
  { _cardListId :: !(Maybe Int64),
    _cardName :: !Text,
    _cardDescription :: !Text,
    _cardCreatedAt :: !UTCTime,
    _cardUpdatedAt :: !UTCTime
  }
  deriving (Eq, Show, Generic)

instance FromRow Board

instance FromField Board where
  fromField f bs = do
    name' <- fromField f bs
    color <- fromField f bs
    createdAt <- fromField f bs
    updatedAt <- fromField f bs
    pure $ Board name' color createdAt updatedAt

instance FromRow List

instance FromField List where
  fromField f bs = do
    boardId <- fromField f bs
    name' <- fromField f bs
    createdAt <- fromField f bs
    updatedAt <- fromField f bs
    pure $ List boardId name' createdAt updatedAt

instance FromRow Label

instance FromField Label where
  fromField f bs = do
    name' <- fromField f bs
    color <- fromField f bs
    createdAt <- fromField f bs
    updatedAt <- fromField f bs
    pure $ Label name' color createdAt updatedAt

instance FromRow Card

instance FromField Card where
  fromField f bs = do
    listId <- fromField f bs
    name' <- fromField f bs
    description' <- fromField f bs
    createdAt <- fromField f bs
    updatedAt <- fromField f bs
    pure $ Card listId name' description' createdAt updatedAt

instance (FromField k, FromRow a) => FromRow (WithKey k a) where
  fromRow = do
    k <- field
    v <- fromRow
    pure $ WithKey {_withKeyId = k, _withKeyValue = v}

instance (ToJSON k, ToJSON a) => ToJSON (WithKey k a) where
  toJSON (WithKey id' a) = object ["id" .= id', "value" .= a]

instance (FromJSON k, FromJSON a) => FromJSON (WithKey k a) where
  parseJSON = withObject "WithKey" $ \o ->
    WithKey <$> o .: "id" <*> o .: "value"

newtype OpenApiSchema = OpenApiSchema {unOpenApiSchema :: OpenApi}
  deriving (Eq, Show, Generic, FromJSON, ToJSON)

instance ToSchema OpenApiSchema where
  declareNamedSchema _ =
    mempty
      & type_ ?~ OpenApiObject
      & description ?~ "An OpenAPI schema, for clients to understand the interface"
      & NamedSchema (Just "OpenApiSchema")
      & pure

runAppM :: App -> AppM a -> IO a
runAppM = runRIO

data App = App
  { _appPostgresqlPool :: !(Pool Connection),
    _appPostgresqlMasterPool :: !(Pool Connection),
    _appLogFunc :: !LogFunc,
    _appOptions :: !Options
  }

data Options = Options
  { _optionsVerbose :: !Bool,
    _optionsPort :: !Int,
    _optionsDatabase :: !DatabaseName
  }

instance HasLogFunc App where
  logFuncL = lens _appLogFunc (\x y -> x {_appLogFunc = y})

data AddBoardParameters = AddBoardParameters
  { _addBoardParametersName :: !Text,
    _addBoardParametersColor :: !Text
  }
  deriving (Eq, Show, Generic)

data AddCardParameters = AddCardParameters
  { _addCardParametersName :: !Text,
    _addCardParametersDescription :: !Text
  }
  deriving (Eq, Show, Generic, Typeable)

instance (ToSchema k, ToSchema v) => ToSchema (WithKey k v) where
  declareNamedSchema =
    genericDeclareNamedSchema
      defaultSchemaOptions {OpenApi.fieldLabelModifier = unlensName "WithKey"}

unlensName :: String -> String -> String
unlensName name' = drop 1 >>> drop (length name') >>> lowerCaseFirstCharacter

foldMapM makeLenses [''App, ''Options]

foldMapM
  deriveLensAndJSON
  [''Board, ''List, ''Label, ''Card, ''AddBoardParameters, ''AddCardParameters]

foldMapM deriveSchema [''Board, ''List, ''Label, ''Card, ''AddBoardParameters, ''AddCardParameters]

instance HasPostgresqlPool App where
  postgresqlPoolL = appPostgresqlPool

instance HasPostgresqlMasterPool App where
  postgresqlMasterPoolL = appPostgresqlMasterPool

{-# START_FILE src/API.hs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}

module API where

import Handlers
import Network.Wai (Middleware)
import Network.Wai.Middleware.Cors
import Qtility hiding (Handler)
import Servant
import Servant.OpenApi (toOpenApi)
import Types

type API = BoardAPI :<|> SchemaAPI

type SchemaAPI = "schema" :> Get '[JSON] OpenApiSchema

type EntityAPI path idName entityId entityValue addingParameters subAPI =
  path
    :> ( Get '[JSON] [WithKey Int64 entityValue]
           :<|> ReqBody '[JSON] addingParameters :> Post '[JSON] (WithKey Int64 entityValue)
           :<|> EntityIdAPI idName entityId entityValue subAPI
       )

type EntityIdAPI idName entityId entityValue subAPI =
  Capture idName entityId
    :> ( Get '[JSON] entityValue
           :<|> ReqBody '[JSON] entityValue :> Put '[JSON] entityValue
           :<|> DeleteNoContent
           :<|> subAPI
       )

type BoardAPI = EntityAPI "boards" "boardId" Int64 Board AddBoardParameters ListAPI

type BoardIdAPI = EntityIdAPI "boardId" Int64 Board ListAPI

type ListAPI = EntityAPI "lists" "listId" Int64 List Text CardAPI

type ListIdAPI = EntityIdAPI "listId" Int64 List CardAPI

type CardAPI = EntityAPI "cards" "cardId" Int64 Card AddCardParameters EmptyAPI

type CardIdAPI = EntityIdAPI "cardId" Int64 Card EmptyAPI

server :: ServerT API AppM
server = serveBoardAPI :<|> getApiSchema

serveBoardAPI :: ServerT BoardAPI AppM
serveBoardAPI = getBoards :<|> addBoard :<|> serveBoardIdAPI

serveBoardIdAPI :: ServerT BoardIdAPI AppM
serveBoardIdAPI boardId =
  getBoard boardId :<|> updateBoard boardId :<|> (deleteBoard boardId >> pure NoContent)
    :<|> serveListAPI boardId

serveListAPI :: Int64 -> ServerT ListAPI AppM
serveListAPI boardId =
  getLists boardId :<|> addList boardId :<|> serveListIdAPI boardId

serveListIdAPI :: Int64 -> ServerT ListIdAPI AppM
serveListIdAPI boardId listId =
  getList boardId listId
    :<|> updateList boardId listId
    :<|> (deleteList boardId listId >> pure NoContent)
    :<|> serveCardAPI boardId listId

serveCardAPI :: Int64 -> Int64 -> ServerT CardAPI AppM
serveCardAPI boardId listId =
  getCards boardId listId :<|> addCard boardId listId :<|> serveCardIdAPI boardId listId

serveCardIdAPI :: Int64 -> Int64 -> ServerT CardIdAPI AppM
serveCardIdAPI boardId listId cardId =
  getCard boardId listId cardId
    :<|> updateCard boardId listId cardId
    :<|> (deleteCard boardId listId cardId >> pure NoContent)
    :<|> emptyServer

appMServer :: App -> Server API
appMServer initialState = hoistServer @API Proxy (runRIO initialState) server

application :: App -> Application
application initialState = do
  corsMiddleware $ serve @API Proxy $ appMServer initialState

corsMiddleware :: Middleware
corsMiddleware =
  cors $
    const $
      Just $
        simpleCorsResourcePolicy
          { corsMethods = ["PUT", "GET", "HEAD", "OPTIONS", "POST"],
            corsOrigins = Nothing, --Just (["http://172.17.44.47:5000"], False),
            corsExposedHeaders = Nothing,
            corsRequestHeaders = ["Content-Type", "Authorization"]
          }

getApiSchema :: AppM OpenApiSchema
getApiSchema = do
  logDebug "Getting schema"
  Proxy @API & toOpenApi & OpenApiSchema & pure

{-# START_FILE src/Handlers.hs #-}
module Handlers where

import qualified Database.Queries as Queries
import Qtility
import Qtility.Database
import RIO.Time (getCurrentTime)
import Types

getBoards :: AppM [WithKey Int64 Board]
getBoards = do
  logDebug "Getting boards"
  runDB Queries.getBoards

getBoard :: Int64 -> AppM Board
getBoard boardId = do
  logDebug $ "Getting board " <> displayShow boardId
  runDB $ Queries.getBoard boardId

addBoard :: AddBoardParameters -> AppM (WithKey Int64 Board)
addBoard parameters = do
  now <- getCurrentTime
  logDebug $ "Adding board: " <> fromString (show parameters)
  runDB $ Queries.addBoard now parameters

updateBoard :: Int64 -> Board -> AppM Board
updateBoard boardId board = do
  now <- getCurrentTime
  logDebug $ "Updating board " <> displayShow boardId <> ": " <> fromString (show board)
  runDB $ Queries.updateBoard now boardId board
  pure board

deleteBoard :: Int64 -> AppM ()
deleteBoard boardId = do
  logDebug $ "Deleting board " <> displayShow boardId
  runDB $ Queries.deleteBoard boardId

getLists :: Int64 -> AppM [WithKey Int64 List]
getLists boardId = do
  logDebug $ "Getting lists for board " <> displayShow boardId
  runDB $ Queries.getLists boardId

addList :: Int64 -> Text -> AppM (WithKey Int64 List)
addList boardId name = do
  now <- getCurrentTime
  let list =
        List
          { _listBoardId = Just boardId,
            _listName = name,
            _listCreatedAt = now,
            _listUpdatedAt = now
          }
  logDebug $ "Adding list: " <> fromString (show list)
  runDB $ Queries.addList now list

getList :: Int64 -> Int64 -> AppM List
getList _boardId listId = do
  logDebug $ "Getting list " <> displayShow listId
  runDB $ Queries.getList listId

deleteList :: Int64 -> Int64 -> AppM ()
deleteList _boardId listId = do
  logDebug $ "Deleting list " <> displayShow listId
  runDB $ Queries.deleteList listId

updateList :: Int64 -> Int64 -> List -> AppM List
updateList _boardId listId list = do
  now <- getCurrentTime
  logDebug $ "Updating list " <> displayShow listId
  runDB $ Queries.updateList now listId list

getCards :: Int64 -> Int64 -> AppM [WithKey Int64 Card]
getCards _boardId listId = do
  logDebug $ "Getting cards for list " <> displayShow listId
  runDB $ Queries.getCards listId

addCard :: Int64 -> Int64 -> AddCardParameters -> AppM (WithKey Int64 Card)
addCard _boardId listId parameters = do
  now <- getCurrentTime
  let card =
        Card
          { _cardListId = Just listId,
            _cardName = parameters ^. addCardParametersName,
            _cardDescription = parameters ^. addCardParametersDescription,
            _cardCreatedAt = now,
            _cardUpdatedAt = now
          }
  logDebug $ "Adding card: " <> fromString (show card)
  runDB $ Queries.addCard now card

getCard :: Int64 -> Int64 -> Int64 -> AppM Card
getCard _boardId _listId cardId = do
  logDebug $ "Getting card " <> displayShow cardId
  runDB $ Queries.getCard cardId

updateCard :: Int64 -> Int64 -> Int64 -> Card -> AppM Card
updateCard _boardId _listId cardId card = do
  now <- getCurrentTime
  logDebug $ "Updating card " <> displayShow cardId
  runDB $ Queries.updateCard now cardId card

deleteCard :: Int64 -> Int64 -> Int64 -> AppM ()
deleteCard _boardId _listId cardId = do
  logDebug $ "Deleting card " <> displayShow cardId
  runDB $ Queries.deleteCard cardId

{-# START_FILE src/Database/Queries.hs #-}
{-# LANGUAGE QuasiQuotes #-}

module Database.Queries where

import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.SqlQQ
import Qtility.Database (DB, HasPostgreSQLConnection (..))
import Qtility.Database.Queries (queryMany, queryOne)
import RIO
import RIO.List.Partial (head)
import RIO.Time (UTCTime)
import Types

getBoards :: DB [WithKey Int64 Board]
getBoards = do
  connection <- view postgreSQLConnectionL
  liftIO $
    query
      connection
      [sql|
      SELECT
        id, name, color, created_at, updated_at
      FROM board
    |]
      ()

getBoard :: Int64 -> DB Board
getBoard boardId = do
  connection <- view postgreSQLConnectionL
  head
    <$> liftIO
      ( query
          connection
          [sql|
        SELECT
          name, color, created_at, updated_at
        FROM board
        WHERE id = ?
      |]
          (Only boardId)
      )

addBoard :: UTCTime -> AddBoardParameters -> DB (WithKey Int64 Board)
addBoard now parameters = do
  queryOne
    [sql|
          INSERT INTO board (name, color, created_at, updated_at)
          VALUES (?, ?, ?, ?)
          RETURNING id, name, color, created_at, updated_at
       |]
    (parameters ^. addBoardParametersName, parameters ^. addBoardParametersColor, now, now)

updateBoard :: UTCTime -> Int64 -> Board -> DB Board
updateBoard now boardId board = do
  queryOne
    [sql|
        UPDATE board
        SET
          name = ?,
          color = ?,
          updated_at = ?
        WHERE id = ?
        RETURNING name, color, created_at, updated_at
      |]
    (board ^. boardName, board ^. boardColor, now, boardId)

deleteBoard :: Int64 -> DB ()
deleteBoard boardId = do
  connection <- view postgreSQLConnectionL
  void $
    liftIO $
      execute
        connection
        [sql|
        DELETE FROM board
        WHERE id = ?
      |]
        (Only boardId)

getLists :: Int64 -> DB [WithKey Int64 List]
getLists boardId =
  queryMany
    [sql|
      SELECT
        id, board_id, name, created_at, updated_at
      FROM list
      WHERE board_id = ?
    |]
    (Only boardId)

getList :: Int64 -> DB List
getList listId =
  queryOne
    [sql|
      SELECT
        board_id, name, created_at, updated_at
      FROM list
      WHERE id = ?
    |]
    (Only listId)

deleteList :: Int64 -> DB ()
deleteList listId = do
  connection <- view postgreSQLConnectionL
  void $
    liftIO $
      execute
        connection
        [sql|
        DELETE FROM list
        WHERE id = ?
      |]
        (Only listId)

addList :: UTCTime -> List -> DB (WithKey Int64 List)
addList now list = do
  queryOne
    [sql|
      INSERT INTO list (board_id, name, created_at, updated_at)
      VALUES (?, ?, ?, ?)
      RETURNING id, board_id, name, created_at, updated_at
    |]
    (list ^. listBoardId, list ^. listName, now, now)

updateList :: UTCTime -> Int64 -> List -> DB List
updateList now listId list = do
  queryOne
    [sql|
      UPDATE list
      SET
        name = ?,
        updated_at = ?
      WHERE id = ?
      RETURNING board_id, name, created_at, updated_at
    |]
    (list ^. listName, now, listId)

getCards :: Int64 -> DB [WithKey Int64 Card]
getCards listId =
  queryMany
    [sql|
      SELECT
        id, list_id, name, description, created_at, updated_at
      FROM card
      WHERE list_id = ?
    |]
    (Only listId)

getCard :: Int64 -> DB Card
getCard cardId =
  queryOne
    [sql|
      SELECT
        list_id, name, description, created_at, updated_at
      FROM card
      WHERE id = ?
    |]
    (Only cardId)

deleteCard :: Int64 -> DB ()
deleteCard cardId = do
  connection <- view postgreSQLConnectionL
  void $
    liftIO $
      execute
        connection
        [sql|
          DELETE FROM card
          WHERE id = ?
        |]
        (Only cardId)

addCard :: UTCTime -> Card -> DB (WithKey Int64 Card)
addCard now card = do
  queryOne
    [sql|
      INSERT INTO card (list_id, name, description, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?)
      RETURNING id, list_id, name, description, created_at, updated_at
    |]
    (card ^. cardListId, card ^. cardName, card ^. cardDescription, now, now)

updateCard :: UTCTime -> Int64 -> Card -> DB Card
updateCard now cardId card = do
  queryOne
    [sql|
      UPDATE card
      SET
        name = ?,
        description = ?,
        updated_at = ?
      WHERE id = ?
      RETURNING list_id, name, description, created_at, updated_at
    |]
    (card ^. cardName, card ^. cardDescription, now, cardId)

{-# START_FILE package.yaml #-}
name:    {{name}}
license: MIT
license-file: LICENSE
version: "0.0.0"

extra-source-files:
- README.md

# Metadata used when publishing your package
# synopsis:            Short description of your package
# category:            Web

# To avoid duplicated efforts in documentation and dealing with the
# complications of embedding Haddock markup inside cabal files, it is
# common to point users to the README.md file.
description:         Please see the README on Github at <https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme>

dependencies:
- base >=4.9.1.0 && <5
- rio
- servant
- servant-server
- servant-openapi3
- openapi3
- qtility
- qtility-db
- wai
- wai-cors
- warp
- resource-pool
- uuid
- bytestring
- aeson-pretty
- lens
- postgresql-simple

default-extensions:
- ApplicativeDo
- BangPatterns
- BinaryLiterals
- ConstraintKinds
- DataKinds
- DefaultSignatures
- DeriveDataTypeable
- DeriveFoldable
- DeriveFunctor
- DeriveGeneric
- DeriveTraversable
- DeriveLift
- DerivingStrategies
- DoAndIfThenElse
- DuplicateRecordFields
- EmptyDataDecls
- EmptyCase
- ExistentialQuantification
- FlexibleContexts
- FlexibleInstances
- FunctionalDependencies
- GADTs
- GeneralizedNewtypeDeriving
- InstanceSigs
- KindSignatures
- LambdaCase
- MultiParamTypeClasses
- MultiWayIf
- NamedFieldPuns
- NoImplicitPrelude
- OverloadedStrings
- PartialTypeSignatures
- PatternGuards
- PolyKinds
- RankNTypes
- RecordWildCards
- ScopedTypeVariables
- StandaloneDeriving
- TupleSections
- TypeFamilies
- TypeSynonymInstances
- ViewPatterns
- TypeApplications

ghc-options:
- -Wall
- -Wcompat
- -Widentities
- -Wincomplete-record-updates
- -Wincomplete-uni-patterns
- -Wpartial-fields
- -Wredundant-constraints
- -Wwarn=deprecations
- -Werror=incomplete-patterns

library:
  source-dirs: src

# Runnable executable for our application
executables:
  {{name}}:
    main: Main.hs
    source-dirs: app
    ghc-options:
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}
    - optparse-simple

# Test suite
tests:
  {{name}}-test:
    main: Spec.hs
    source-dirs: test
    ghc-options: -Wall
    dependencies:
    - {{name}}
    - hspec-wai
    - wai-extra
    - hspec >=2.0.0
    - http-types

{-# START_FILE stack.yaml #-}
resolver: lts-18.28

packages:
- .

allow-different-user: true

extra-deps:
- github: quanterall/qtility
  commit:  commit: feebd3658c48ca15caea9007f2a545019a246521
  subdirs:
  - qtility
  - qtility-db
  # nix-sha256: sha256-GKn9DqlG5TdJVoUXRaYxXN8UPxgSq/coswpc4O049Eg= 01c4fc42756611da9d3dc04e9ac71ece6ae67268

nix:
  packages: 
  - zlib
  - postgresql

{-# START_FILE test/Spec.hs #-}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}

{-# START_FILE test/ServerSpec.hs #-}
{-# LANGUAGE TypeApplications #-}

module ServerSpec where

import Network.Wai.Test (SResponse (..))
import Qtility
import Run
import Test.Hspec
import Test.Hspec.Wai
import TestUtilities
import Types

spec :: Spec
spec = do
  (state, app) <-
    runIO $
      createApplication
        Options
          { _optionsPort = 8888,
            _optionsVerbose = False,
            _optionsDatabase = "{{name}}-web-test"
          }
  around_ (setupServer state app) $ do
    with (pure app) $ do
      describe "GET /boards" $ do
        it "responds with empty list when we don't have boards" $ do
          get "/boards" `shouldRespondWith` "[]"

      describe "POST /boards" $ do
        it "can add a board and read it, then delete it" $ do
          let parameters =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          postTo "/boards" parameters `shouldRespondWith` 200
          Just [WithKey boardId boardValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 Board] >>> hush) <$> get "/boards"
          get ("/boards/" <> fromString (show boardId))
            `shouldRespondWith` equalDecoded 200 boardValue
          delete ("/boards/" <> fromString (show boardId)) `shouldRespondWith` 204

      describe "PUT /boards/:id" $ do
        it "can update a board" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (_boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          Just [WithKey (boardId :: Int64) boardValue] <-
            (simpleBody >>> eitherDecode >>> hush) <$> get "/boards"
          let updatedBoard = boardValue & boardName .~ "Test board 2" & boardColor .~ "blue"
          putTo ("/boards/" <> fromString (show boardId)) updatedBoard
            `shouldRespondWith` equalDecoded 200 updatedBoard
          receivedUpdatedBoard <- decodedResponse <$> get ("/boards/" <> fromString (show boardId))
          liftIO $ receivedUpdatedBoard ^. boardName `shouldBe` updatedBoard ^. boardName
          liftIO $ receivedUpdatedBoard ^. boardColor `shouldBe` updatedBoard ^. boardColor
          liftIO $ receivedUpdatedBoard ^. boardCreatedAt `shouldBe` updatedBoard ^. boardCreatedAt
          delete ("/boards/" <> fromString (show boardId)) `shouldRespondWith` 204

      describe "GET /boards/:id/lists" $ do
        it "responds with empty list when we don't have lists" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (_boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          Just [WithKey boardId _boardValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 Board] >>> hush) <$> get "/boards"
          get ("/boards/" <> fromString (show boardId) <> "/lists")
            `shouldRespondWith` "[]"
          delete ("/boards/" <> fromString (show boardId)) `shouldRespondWith` 204

      describe "POST /boards/:id/lists" $ do
        it "can add a list and read it, then delete it" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          let list :: Text = "Test list 1"
          postTo ("/boards/" <> fromString (show boardId) <> "/lists") list
            `shouldRespondWith` 200
          Just [WithKey listId listValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 List] >>> hush) <$> get ("/boards/" <> fromString (show boardId) <> "/lists")

          get ("/boards/" <> fromString (show boardId) <> "/lists/" <> fromString (show listId))
            `shouldRespondWith` equalDecoded 200 listValue

          delete ("/boards/" <> fromString (show boardId) <> "/lists/" <> fromString (show listId))
            `shouldRespondWith` 204

          delete ("/boards/" <> fromString (show boardId)) `shouldRespondWith` 204

      describe "PUT /boards/:id/lists/:id" $ do
        it "can update a list" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          let list :: Text = "Test list 1"
          postTo ("/boards/" <> fromString (show boardId) <> "/lists") list
            `shouldRespondWith` 200
          Just [WithKey listId listValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 List] >>> hush)
              <$> get ("/boards/" <> fromString (show boardId) <> "/lists")
          let updatedList = listValue & listName .~ "Test list 2"
          receivedUpdatedList <-
            decodedResponse
              <$> putTo
                ( "/boards/"
                    <> fromString (show boardId)
                    <> "/lists/"
                    <> fromString (show listId)
                )
                updatedList
          liftIO $ receivedUpdatedList ^. listName `shouldBe` updatedList ^. listName
          liftIO $ receivedUpdatedList ^. listCreatedAt `shouldBe` updatedList ^. listCreatedAt
          liftIO $ receivedUpdatedList ^. listBoardId `shouldBe` updatedList ^. listBoardId
          liftIO $ receivedUpdatedList ^. listUpdatedAt `shouldNotBe` updatedList ^. listUpdatedAt
          get ("/boards/" <> fromString (show boardId) <> "/lists/" <> fromString (show listId))
            `shouldRespondWith` equalDecoded 200 receivedUpdatedList
          delete ("/boards/" <> fromString (show boardId) <> "/lists/" <> fromString (show listId))
            `shouldRespondWith` 204

          delete ("/boards/" <> fromString (show boardId)) `shouldRespondWith` 204

      describe "GET /boards/:id/lists/:id/cards" $ do
        it "responds with empty list when we don't have cards" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          let list :: Text = "Test list 1"
          postTo ("/boards/" <> fromString (show boardId) <> "/lists") list
            `shouldRespondWith` 200
          Just [WithKey listId _listValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 List] >>> hush)
              <$> get ("/boards/" <> fromString (show boardId) <> "/lists")
          get
            ( "/boards/"
                <> fromString (show boardId)
                <> "/lists/"
                <> fromString (show listId)
                <> "/cards"
            )
            `shouldRespondWith` "[]"
          delete ("/boards/" <> fromString (show boardId) <> "/lists/" <> fromString (show listId))
            `shouldRespondWith` 204

      describe "POST /boards/:id/lists/:id/cards" $ do
        it "can add a card and read it, then delete it" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          let list :: Text = "Test list 1"
          postTo ("/boards/" <> fromString (show boardId) <> "/lists") list
            `shouldRespondWith` 200
          Just [WithKey listId _listValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 List] >>> hush)
              <$> get ("/boards/" <> fromString (show boardId) <> "/lists")
          let card =
                AddCardParameters
                  { _addCardParametersName = "Test card 1",
                    _addCardParametersDescription = "Test card 1 description"
                  }
          WithKey (cardId :: Int64) addedCard <-
            decodedResponse
              <$> postTo
                ( "/boards/"
                    <> fromString (show boardId)
                    <> "/lists/"
                    <> fromString (show listId)
                    <> "/cards"
                )
                card
          liftIO $ addedCard ^. cardName `shouldBe` card ^. addCardParametersName
          liftIO $ addedCard ^. cardDescription `shouldBe` card ^. addCardParametersDescription

          Just [WithKey _cardId cardValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 Card] >>> hush)
              <$> get
                ( "/boards/"
                    <> fromString (show boardId)
                    <> "/lists/"
                    <> fromString (show listId)
                    <> "/cards"
                )
          liftIO $ cardValue ^. cardName `shouldBe` addedCard ^. cardName
          liftIO $ cardValue ^. cardDescription `shouldBe` addedCard ^. cardDescription
          liftIO $ cardValue ^. cardCreatedAt `shouldBe` addedCard ^. cardCreatedAt
          liftIO $ cardValue ^. cardUpdatedAt `shouldBe` addedCard ^. cardUpdatedAt
          liftIO $ cardValue ^. cardListId `shouldBe` addedCard ^. cardListId

          get
            ( "/boards/"
                <> fromString (show boardId)
                <> "/lists/"
                <> fromString (show listId)
                <> "/cards/"
                <> fromString (show cardId)
            )
            `shouldRespondWith` equalDecoded 200 cardValue

          delete ("/boards/" <> fromString (show boardId) <> "/lists/" <> fromString (show listId) <> "/cards/" <> fromString (show cardId))
            `shouldRespondWith` 204

      describe "PUT /boards/:id/lists/:id/cards/:id" $ do
        it "can update a card" $ do
          let board =
                AddBoardParameters
                  { _addBoardParametersName = "Test board 1",
                    _addBoardParametersColor = "green"
                  }
          WithKey (boardId :: Int64) addedBoard <- decodedResponse <$> postTo "/boards" board
          liftIO $ addedBoard ^. boardName `shouldBe` board ^. addBoardParametersName
          liftIO $ addedBoard ^. boardColor `shouldBe` board ^. addBoardParametersColor
          let list :: Text = "Test list 1"
          postTo ("/boards/" <> fromString (show boardId) <> "/lists") list
            `shouldRespondWith` 200
          Just [WithKey listId _listValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 List] >>> hush)
              <$> get ("/boards/" <> fromString (show boardId) <> "/lists")
          let card =
                AddCardParameters
                  { _addCardParametersName = "Test card 1",
                    _addCardParametersDescription = "Test card 1 description"
                  }
          postTo
            ( "/boards/"
                <> fromString (show boardId)
                <> "/lists/"
                <> fromString (show listId)
                <> "/cards"
            )
            card
            `shouldRespondWith` 200
          Just [WithKey cardId cardValue] <-
            (simpleBody >>> eitherDecode @[WithKey Int64 Card] >>> hush)
              <$> get
                ( "/boards/"
                    <> fromString (show boardId)
                    <> "/lists/"
                    <> fromString (show listId)
                    <> "/cards"
                )
          let updatedCard =
                cardValue & cardName .~ "Test card 2" & cardDescription .~ "Test card 2 description"
          receivedUpdatedCard <-
            decodedResponse
              <$> putTo
                ( "/boards/"
                    <> fromString (show boardId)
                    <> "/lists/"
                    <> fromString (show listId)
                    <> "/cards/"
                    <> fromString (show cardId)
                )
                updatedCard
          liftIO $ receivedUpdatedCard ^. cardName `shouldBe` updatedCard ^. cardName
          liftIO $ receivedUpdatedCard ^. cardDescription `shouldBe` updatedCard ^. cardDescription

{-# START_FILE test/TestUtilities.hs #-}
{-# LANGUAGE QuasiQuotes #-}

module TestUtilities where

import Control.Concurrent (forkIO, killThread)
import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.SqlQQ (sql)
import Network.HTTP.Types.Method
import Network.Wai (Application)
import Network.Wai.Handler.Warp (run)
import Network.Wai.Test (SResponse (..))
import Qtility
import Qtility.Database (DB, HasPostgreSQLConnection (..), runDB)
import Qtility.Database.Migration (createMigrationTable)
import Qtility.Database.Migration.Queries (applyMigrations)
import Test.Hspec.Wai
import Types

deleteCards :: DB ()
deleteCards = do
  connection <- view postgreSQLConnectionL
  liftIO $ void $ execute_ connection [sql|DELETE FROM card|]

deleteLists :: DB ()
deleteLists = do
  connection <- view postgreSQLConnectionL
  liftIO $ void $ execute_ connection [sql|DELETE FROM list|]

deleteBoards :: DB ()
deleteBoards = do
  connection <- view postgreSQLConnectionL
  liftIO $ void $ execute_ connection [sql|DELETE FROM board|]

setupServer :: App -> Application -> IO () -> IO ()
setupServer app application action = do
  runAppM app $ do
    migrations <- createMigrationTable Nothing "migrations"
    runDB $ applyMigrations Nothing migrations
    runDB deleteCards
    runDB deleteLists
    runDB deleteBoards
  bracket (forkIO $ run 8888 application) killThread (const action)

postTo :: (ToJSON a) => ByteString -> a -> WaiSession st SResponse
postTo path value =
  request methodPost path [("Content-Type", "application/json")] (encode value)

decodedResponse :: (FromJSON a) => SResponse -> a
decodedResponse response = case eitherDecode $ simpleBody response of
  Left err -> error err
  Right val -> val

putTo :: (ToJSON a) => ByteString -> a -> WaiSession st SResponse
putTo path value =
  request methodPut path [("Content-Type", "application/json")] (encode value)

equalDecoded :: (FromJSON a, Eq a, Show a) => ResponseMatcher -> a -> ResponseMatcher
equalDecoded matcher a = matcher {matchBody = MatchBody $ matchDecodedValue a}
  where
    matchDecodedValue a' _headers body = do
      decodedBody <- hush $ eitherDecode body
      if decodedBody == a'
        then Nothing
        else Just $ "Expected: " ++ show a' ++ "\nActual: " ++ show decodedBody

{-# START_FILE default.nix #-}
let
  # Read in the Niv sources
  sources = import ./nix/sources.nix {};
  # If ./nix/sources.nix file is not found run:
  #   niv init
  #   niv add input-output-hk/haskell.nix -n haskellNix

  # Fetch the haskell.nix commit we have pinned with Niv
  haskellNix = import sources.haskellNix {};
  # If haskellNix is not found run:
  #   niv add input-output-hk/haskell.nix -n haskellNix

  # Import nixpkgs and pass the haskell.nix provided nixpkgsArgs
  pkgs = import
    # haskell.nix provides access to the nixpkgs pins which are used by our CI,
    # hence you will be more likely to get cache hits when using these.
    # But you can also just use your own, e.g. '<nixpkgs>'.
    haskellNix.sources.nixpkgs-unstable
    # These arguments passed to nixpkgs, include some patches and also
    # the haskell.nix functionality itself as an overlay.
    haskellNix.nixpkgsArgs;
in pkgs.haskell-nix.project {
  # 'cleanGit' cleans a source directory based on the files known by git
  src = pkgs.haskell-nix.haskellLib.cleanGit {
    name = "{{name}}";
    src = ./.;
  };
}

{-# START_FILE shell.nix #-}
let
  pkgs = import <nixpkgs> { };
in (import ./default.nix).shellFor {
  withHoogle = true;

  tools = {
    cabal = "3.2.0.0";
    hlint = "latest";
    ormolu = "0.3.1.0";
  };

  exactDeps = true;
}

{-# START_FILE .ghci #-}
:set -package pretty-simple
:set -XOverloadedStrings
:set -interactive-print=Text.Pretty.Simple.pPrint
import qualified Prelude
:def hoogle \x -> Prelude.pure Prelude.$ ":!hoogle " Prelude.<> x
:set prompt "Q> "

{-# START_FILE .vscode/extensions.json #-}
{
	// See https://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.
	// Extension identifier format: ${publisher}.${name}. Example: vscode.csharp

	// List of extensions which should be recommended for users of this workspace.
	"recommendations": [
        "sjurmillidahl.ormolu-vscode",
        "dramforever.vscode-ghc-simple",
        "hoovercj.haskell-linter",
        "gonzooo.at-notes",
        "sleistner.vscode-fileutils",
        "fayras.simple-new-file",
        "jcanero.hoogle-vscode",
        "mel-brown.haskell-yesod-quasiquotes",
        "GoNZooo.hoogle-webview"
	],
	// List of extensions recommended by VS Code that should not be recommended for users of this workspace.
	"unwantedRecommendations": []
}

{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE docker-compose.yml #-}
version: '3'

services:
  postgresql:
    image: postgres:14
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: {{name}}
    ports:
      - "5432:5432"
    volumes:
      - {{name}}-db:/var/lib/postgresql/data

volumes:
  {{name}}-db:

{-# START_FILE migrations/2022-05-03_10-39-08_-_create-tables.sql #-}
SET LOCAL client_min_messages = warning;

CREATE TABLE IF NOT EXISTS "board" (
  "id" serial PRIMARY KEY,
  "name" text NOT NULL,
  "color" text NOT NULL,
  "created_at" timestamp with time zone NOT NULL,
  "updated_at" timestamp with time zone NOT NULL
);

CREATE TABLE IF NOT EXISTS "list" (
  "id" serial PRIMARY KEY,
  "board_id" serial REFERENCES "board" (id),
  "name" text NOT NULL,
  "created_at" timestamp with time zone NOT NULL,
  "updated_at" timestamp with time zone NOT NULL
);

CREATE TABLE IF NOT EXISTS "label" (
  "id" serial PRIMARY KEY,
  "name" text NOT NULL,
  "color" text NOT NULL,
  "created_at" timestamp with time zone NOT NULL,
  "updated_at" timestamp with time zone NOT NULL
);

CREATE TABLE IF NOT EXISTS "card" (
  "id" serial PRIMARY KEY,
  "list_id" serial REFERENCES "list" (id),
  "name" text NOT NULL,
  "description" text NOT NULL,
  "created_at" timestamp with time zone NOT NULL,
  "updated_at" timestamp with time zone NOT NULL
);


-- DOWN

DROP TABLE "board";
DROP TABLE "list";
DROP TABLE "label";
DROP TABLE "card";

{-# START_FILE hie.yml #-}
cradle:
  stack:
    - path: "./app/Main.hs"
      component: "{{name}}:exe:{{name}}"

    - path: "./src"
      component: "{{name}}:lib"

    - path: "./app/Paths_{{name-as-varid}}.hs"
      component: "{{name}}:exe:{{name}}"

    - path: "./test"
      component: "{{name}}:test:{{name}}-test"

{-# START_FILE nix/sources.nix #-}
# This file has been generated by Niv.

let

  #
  # The fetchers. fetch_<type> fetches specs of type <type>.
  #

  fetch_file = pkgs: name: spec:
    let
      name' = sanitizeName name + "-src";
    in
      if spec.builtin or true then
        builtins_fetchurl { inherit (spec) url sha256; name = name'; }
      else
        pkgs.fetchurl { inherit (spec) url sha256; name = name'; };

  fetch_tarball = pkgs: name: spec:
    let
      name' = sanitizeName name + "-src";
    in
      if spec.builtin or true then
        builtins_fetchTarball { name = name'; inherit (spec) url sha256; }
      else
        pkgs.fetchzip { name = name'; inherit (spec) url sha256; };

  fetch_git = name: spec:
    let
      ref =
        if spec ? ref then spec.ref else
          if spec ? branch then "refs/heads/${spec.branch}" else
            if spec ? tag then "refs/tags/${spec.tag}" else
              abort "In git source '${name}': Please specify `ref`, `tag` or `branch`!";
    in
      builtins.fetchGit { url = spec.repo; inherit (spec) rev; inherit ref; };

  fetch_local = spec: spec.path;

  fetch_builtin-tarball = name: throw
    ''[${name}] The niv type "builtin-tarball" is deprecated. You should instead use `builtin = true`.
        $ niv modify ${name} -a type=tarball -a builtin=true'';

  fetch_builtin-url = name: throw
    ''[${name}] The niv type "builtin-url" will soon be deprecated. You should instead use `builtin = true`.
        $ niv modify ${name} -a type=file -a builtin=true'';

  #
  # Various helpers
  #

  # https://github.com/NixOS/nixpkgs/pull/83241/files#diff-c6f540a4f3bfa4b0e8b6bafd4cd54e8bR695
  sanitizeName = name:
    (
      concatMapStrings (s: if builtins.isList s then "-" else s)
        (
          builtins.split "[^[:alnum:]+._?=-]+"
            ((x: builtins.elemAt (builtins.match "\\.*(.*)" x) 0) name)
        )
    );

  # The set of packages used when specs are fetched using non-builtins.
  mkPkgs = sources: system:
    let
      sourcesNixpkgs =
        import (builtins_fetchTarball { inherit (sources.nixpkgs) url sha256; }) { inherit system; };
      hasNixpkgsPath = builtins.any (x: x.prefix == "nixpkgs") builtins.nixPath;
      hasThisAsNixpkgsPath = <nixpkgs> == ./.;
    in
      if builtins.hasAttr "nixpkgs" sources
      then sourcesNixpkgs
      else if hasNixpkgsPath && ! hasThisAsNixpkgsPath then
        import <nixpkgs> {}
      else
        abort
          ''
            Please specify either <nixpkgs> (through -I or NIX_PATH=nixpkgs=...) or
            add a package called "nixpkgs" to your sources.json.
          '';

  # The actual fetching function.
  fetch = pkgs: name: spec:

    if ! builtins.hasAttr "type" spec then
      abort "ERROR: niv spec ${name} does not have a 'type' attribute"
    else if spec.type == "file" then fetch_file pkgs name spec
    else if spec.type == "tarball" then fetch_tarball pkgs name spec
    else if spec.type == "git" then fetch_git name spec
    else if spec.type == "local" then fetch_local spec
    else if spec.type == "builtin-tarball" then fetch_builtin-tarball name
    else if spec.type == "builtin-url" then fetch_builtin-url name
    else
      abort "ERROR: niv spec ${name} has unknown type ${builtins.toJSON spec.type}";

  # If the environment variable NIV_OVERRIDE_${name} is set, then use
  # the path directly as opposed to the fetched source.
  replace = name: drv:
    let
      saneName = stringAsChars (c: if isNull (builtins.match "[a-zA-Z0-9]" c) then "_" else c) name;
      ersatz = builtins.getEnv "NIV_OVERRIDE_${saneName}";
    in
      if ersatz == "" then drv else
        # this turns the string into an actual Nix path (for both absolute and
        # relative paths)
        if builtins.substring 0 1 ersatz == "/" then /. + ersatz else /. + builtins.getEnv "PWD" + "/${ersatz}";

  # Ports of functions for older nix versions

  # a Nix version of mapAttrs if the built-in doesn't exist
  mapAttrs = builtins.mapAttrs or (
    f: set: with builtins;
    listToAttrs (map (attr: { name = attr; value = f attr set.${attr}; }) (attrNames set))
  );

  # https://github.com/NixOS/nixpkgs/blob/0258808f5744ca980b9a1f24fe0b1e6f0fecee9c/lib/lists.nix#L295
  range = first: last: if first > last then [] else builtins.genList (n: first + n) (last - first + 1);

  # https://github.com/NixOS/nixpkgs/blob/0258808f5744ca980b9a1f24fe0b1e6f0fecee9c/lib/strings.nix#L257
  stringToCharacters = s: map (p: builtins.substring p 1 s) (range 0 (builtins.stringLength s - 1));

  # https://github.com/NixOS/nixpkgs/blob/0258808f5744ca980b9a1f24fe0b1e6f0fecee9c/lib/strings.nix#L269
  stringAsChars = f: s: concatStrings (map f (stringToCharacters s));
  concatMapStrings = f: list: concatStrings (map f list);
  concatStrings = builtins.concatStringsSep "";

  # https://github.com/NixOS/nixpkgs/blob/8a9f58a375c401b96da862d969f66429def1d118/lib/attrsets.nix#L331
  optionalAttrs = cond: as: if cond then as else {};

  # fetchTarball version that is compatible between all the versions of Nix
  builtins_fetchTarball = { url, name ? null, sha256 }@attrs:
    let
      inherit (builtins) lessThan nixVersion fetchTarball;
    in
      if lessThan nixVersion "1.12" then
        fetchTarball ({ inherit url; } // (optionalAttrs (!isNull name) { inherit name; }))
      else
        fetchTarball attrs;

  # fetchurl version that is compatible between all the versions of Nix
  builtins_fetchurl = { url, name ? null, sha256 }@attrs:
    let
      inherit (builtins) lessThan nixVersion fetchurl;
    in
      if lessThan nixVersion "1.12" then
        fetchurl ({ inherit url; } // (optionalAttrs (!isNull name) { inherit name; }))
      else
        fetchurl attrs;

  # Create the final "sources" from the config
  mkSources = config:
    mapAttrs (
      name: spec:
        if builtins.hasAttr "outPath" spec
        then abort
          "The values in sources.json should not have an 'outPath' attribute"
        else
          spec // { outPath = replace name (fetch config.pkgs name spec); }
    ) config.sources;

  # The "config" used by the fetchers
  mkConfig =
    { sourcesFile ? if builtins.pathExists ./sources.json then ./sources.json else null
    , sources ? if isNull sourcesFile then {} else builtins.fromJSON (builtins.readFile sourcesFile)
    , system ? builtins.currentSystem
    , pkgs ? mkPkgs sources system
    }: rec {
      # The sources, i.e. the attribute set of spec name to spec
      inherit sources;

      # The "pkgs" (evaluated nixpkgs) to use for e.g. non-builtin fetchers
      inherit pkgs;
    };

in
mkSources (mkConfig {}) // { __functor = _: settings: mkSources (mkConfig settings); }

{-# START_FILE nix/sources.json #-}
{
    "haskellNix": {
        "branch": "master",
        "description": "Alternative Haskell Infrastructure for Nixpkgs",
        "homepage": "https://input-output-hk.github.io/haskell.nix",
        "owner": "input-output-hk",
        "repo": "haskell.nix",
        "rev": "23553a5ec79ae422125c8cb0e0abec5e2ad487a9",
        "sha256": "07rm4qz0jspyas7myvac5x6rsf31hh3yc2a9rzxikr9kfsrmgdkb",
        "type": "tarball",
        "url": "https://github.com/input-output-hk/haskell.nix/archive/23553a5ec79ae422125c8cb0e0abec5e2ad487a9.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    },
    "niv": {
        "branch": "master",
        "description": "Easy dependency management for Nix projects",
        "homepage": "https://github.com/nmattia/niv",
        "owner": "nmattia",
        "repo": "niv",
        "rev": "5830a4dd348d77e39a0f3c4c762ff2663b602d4c",
        "sha256": "1d3lsrqvci4qz2hwjrcnd8h5vfkg8aypq3sjd4g3izbc8frwz5sm",
        "type": "tarball",
        "url": "https://github.com/nmattia/niv/archive/5830a4dd348d77e39a0f3c4c762ff2663b602d4c.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    }
}

{-# START_FILE .gitignore #-}
*.hi
*.o
.hsenv*
cabal-dev/
.stack-work/
.cabal-sandbox
cabal.sandbox.config
.DS_Store
*.swp
*~
\#*
.devcontainer/build

{-# START_FILE .devcontainer/docker-compose.yaml #-}
version: '3'

services:
  {{name}}:
    image: gonz/quanterall-application-development:lts-18.28
    volumes:
      - ..:/workspace:cached
      - ./build/stack-work:/workspace/.stack-work:cached
    command: /bin/sh -c "while sleep 1000; do :; done"

  postgresql:
    image: postgres:14
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: {{name}}
    ports:
      - "5432:5432"
    volumes:
      - {{name}}-db:/var/lib/postgresql/data

volumes:
  {{name}}-db:

networks:
  default:
    driver: bridge

{-# START_FILE .devcontainer/devcontainer.json #-}
{
  "name": "{{name}}",
  "service": "{{name}}",
  "workspaceFolder": "/workspace",
  "dockerComposeFile": "./docker-compose.yaml",
  "extensions": [
    "sjurmillidahl.ormolu-vscode",
    "dramforever.vscode-ghc-simple",
    "lunaryorn.hlint",
    "gonzooo.at-notes",
    "sleistner.vscode-fileutils",
    "fayras.simple-new-file",
    "jcanero.hoogle-vscode"
  ],
  "settings": {
    "[haskell]": {
      "editor.tabSize": 2,
      "editor.formatOnSave": true,
      "editor.defaultFormatter": "sjurmillidahl.ormolu-vscode",
      "editor.renderIndentGuides": true
    }
  }
}

{-# START_FILE README.md #-}
# {{name}}

API template using [Servant](https://docs.servant.dev/en/stable/).

Start editing code in the `src` directory!

Run tests with `stack test --fast --file-watch`!

{-# START_FILE LICENSE #-}
Copyright {{year}} {{author}}

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

{-# START_FILE .vscode/settings.json #-}
{
  "hoogle-vscode.url": "http://localhost:8888/",
  "hoogle-vscode.maxResults": 10,
  "hoogle-webview.hoogleUrl": "http://localhost:8888/"  
}

{-# START_FILE dev-scripts/run-hoogle.sh #-}
#!/usr/bin/env sh

hoogle serve --local --host localhost --port 8888 --no-security-headers
